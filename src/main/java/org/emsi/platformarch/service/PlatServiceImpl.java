package org.emsi.platformarch.service;import com.google.api.core.ApiFuture;import com.google.cloud.firestore.*;import com.google.firebase.cloud.FirestoreClient;import com.mathworks.engine.MatlabEngine;import jakarta.persistence.EntityNotFoundException;import jakarta.transaction.Transactional;import lombok.extern.slf4j.Slf4j;import org.emsi.platformarch.clustering.*;import org.emsi.platformarch.clustering.Record;import org.emsi.platformarch.entities.Charges;import org.emsi.platformarch.entities.Project;import org.emsi.platformarch.entities.Userr;import org.emsi.platformarch.firebaseData.Sys;import org.emsi.platformarch.firebaseData.WeatherForecast;import org.emsi.platformarch.repository.ChargeRepository;import org.emsi.platformarch.repository.ProjectRepository;import org.emsi.platformarch.repository.UserRepository;import org.emsi.platformarch.requests.*;import org.emsi.platformarch.service.feign.BatchServiceRest;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;import java.time.Instant;import java.util.*;import java.util.concurrent.ExecutionException;import java.util.concurrent.ThreadLocalRandom;import java.util.stream.LongStream;import static java.lang.Math.E;import static java.lang.Math.exp;import static java.util.stream.Collectors.toSet;@Slf4j@Service@Transactionalpublic class PlatServiceImpl implements IPlatService {    private UserRepository userRepository;    private ProjectRepository projectRepository;    private ChargeRepository chargeRepository;    private static MatlabEngine eng;    private final BatchServiceRest batchServiceRest;    public PlatServiceImpl(UserRepository userRepository, ProjectRepository projectRepository, ChargeRepository chargeRepository, BatchServiceRest batchServiceRest) {        this.userRepository = userRepository;        this.projectRepository = projectRepository;        this.chargeRepository = chargeRepository;        this.batchServiceRest=batchServiceRest;    }    @Override    public Userr saveUser(Userr user) {        if (userRepository.existsByMail(user.getMail())) {            // Si la charge existe déjà, il s'agit d'une mise à jour, pas d'une nouvelle insertion            return user; // Mettre à jour la charge existante Ne faire rien        } else {            // Si la charge n'existe pas encore, il s'agit d'une nouvelle insertion            user.setId(Instant.now().toEpochMilli()); // Attribuer un nouvel identifiant            System.out.println("Nouveau user ajoutée avec l'ID: " + user.getId());            return userRepository.save(user);            // Insérer la nouvelle charge dans la base de données        }        //il faut faire des regles metiers ici    }    @Override    public Project saveProject(Project project) {        System.out.println("we are in save project : " + project.getId() + " - " + project.getLongitude());        //il faut préciser pour quel user ce project        project.setId(UUID.randomUUID().toString());        return projectRepository.save(project);    }    @Override    public void deleteProjectById(String id) {        projectRepository.deleteById(id);    }    public Charges saveOrUpdateCharge(Charges charges) {        // Vérifier si la charge existe déjà dans la base de données        if (charges.getId() != null && chargeRepository.existsById(charges.getId())) {            // Si la charge existe déjà, il s'agit d'une mise à jour, pas d'une nouvelle insertion            return chargeRepository.save(charges); // Mettre à jour la charge existante        } else {            // Si la charge n'existe pas encore, il s'agit d'une nouvelle insertion            charges.setId(UUID.randomUUID().toString()); // Attribuer un nouvel identifiant            System.out.println("Nouvelle charge ajoutée avec l'ID: " + charges.getId());            return chargeRepository.save(charges); // Insérer la nouvelle charge dans la base de données        }    }    @Override    public List<Project> findAllProjects() {        return projectRepository.findAll();    }    @Override    public List<Userr> findAllUsers() {        return userRepository.findAll();    }    @Override    public List<Charges> findAllCharges() {        return chargeRepository.findAll();    }    @Override    public Project findByName(String name) {        return null;    }    @Override    public ResponseEntity<Project> findProjectById(String id) {//elle recupere l'entité complete        Project project = projectRepository.findById(id)                .orElseThrow(() -> new RuntimeException("Project not exist with id: " + id));        return ResponseEntity.ok(project);    }    @Override    public ResponseEntity<Charges> findChargeById(String id) {    //elle recupere l'entité complete        Charges charges = chargeRepository.findById(id)                .orElseThrow(() -> new RuntimeException("charge not exist with id: " + id));        return ResponseEntity.ok(charges);    }    @Override    public void addChargeToProject(String projectId, Charges charge) {        try {            //on veux ajouter une charge pour un seul projet            //un projet deja existe dans la bdd, le user envoie la nouvelle charge, et donc on ajoute la charge au projet existant            //on doit recupere le projet            ResponseEntity<Project> projectOptional = findProjectById(projectId);            Project project = projectOptional.getBody();            System.out.println("les charges de ce project : " + project.getCharges());            System.out.println("Le project: " + project);            System.out.println("L'heure de marche de charge: " + charge.getHeureMarche());            if (project == null) {                throw new EntityNotFoundException("Aucun projet trouvé avec l'ID spécifié: " + projectId);            }            // Assurez-vous que l'objet charge n'est pas null            if (charge == null) {                throw new IllegalArgumentException("L'objet charge ne peut pas être null.");            }            //on doit récupérer la charge aussi ms avant on doit l'enregistrer dans la bdd            //  chargeRepository.save(charge);            saveOrUpdateCharge(charge);            String chargeId = charge.getId();            ResponseEntity<Charges> chargesOprional = findChargeById(chargeId);            Charges chargess = chargesOprional.getBody();            if (project.getCharges() != null) {                project.getCharges().add(chargess);                chargess.getProjects().add(project);            }            System.out.println("les charges de ce project apres l'ajout de charge: " + project.getCharges());            // Sauvegardez le projet mis à jour dans la base de données            projectRepository.save(project);            //une fois que j'ajoute la charge au niveau du projet , le projet doit etre ajouté au niveau de l'entité charges            //ms dans notre cas on a pas des charges prédéfinies, nous meme on ajoute la charge , nv charge .            // return projectRepository.save(project);        } catch (EntityNotFoundException e) {            // Gérez le cas où aucun projet n'est trouvé            // Vous pouvez journaliser l'erreur ou renvoyer une réponse appropriée à l'utilisateur            // Dans cet exemple, nous lançons une RuntimeException avec un message d'erreur spécifique            throw new RuntimeException("Aucun projet trouvé avec l'ID spécifié: " + projectId);        } catch (IllegalArgumentException e) {            // Gérez le cas où l'objet charge est null            // Vous pouvez journaliser l'erreur ou renvoyer une réponse appropriée à l'utilisateur            // Dans cet exemple, nous lançons une RuntimeException avec un message d'erreur spécifique            throw new RuntimeException("L'objet charge ne peut pas être null.");        } catch (RuntimeException e) {            // Gérez d'autres exceptions inattendues            // Vous pouvez journaliser l'erreur ou renvoyer une réponse appropriée à l'utilisateur            // Dans cet exemple, nous imprimons simplement l'erreur            e.printStackTrace();            // Vous pouvez également choisir de lancer une exception spécifique ou de renvoyer une réponse d'erreur appropriée            throw new RuntimeException("Erreur lors de l'ajout de la charge au projet: " + e.getMessage());        }    }    @Override    public List<Charges> findChargesByProject(String projectId) {        //on doit recupere le projet        ResponseEntity<Project> projectById = findProjectById(projectId);        Project project = projectById.getBody();        List<Charges> charges = project.getCharges();        System.out.println("*********************");        System.out.println("project id : " + projectId);        System.out.println("Ses charges : " + charges);        System.out.println("premiere charge: " + charges.get(0).getQuantity() + "**" + charges.get(0).getHeureMarche());        return charges;    }    public long[] calculateEnergy(List<Charges> charges) {        long puissance;        long quantity;        int heureM;        int heureA;/*        let splits = event.split(':'); // splits should have an array with two values, based on the value. for ex, given the time '11:23', it will be an array ['11','23']        hours = +(splits[0]) // take the first value and numberify it. so in the prev ex, take '11' and make it 11        let endHour = hours+1 // don't forget to add logic for midnight etc (not included)        let newtimestring = endHour.tostring() + ':' + splits[1] // create the new endtime with the incremented hour concatenated with the minutes*/        // Algorithme #1        int size = charges.size();        long[][] M = new long[size][4];        for (int i = 0; i < size; i++) {            // Parsing start time (heure marche)            String startTime = charges.get(i).getHeureMarche();            String[] startTimeParts = startTime.split(":");            int startHour = Integer.parseInt(startTimeParts[0]);            // Parsing end time (heure arret)            String endTime = charges.get(i).getHeureArret();            String[] endTimeParts = endTime.split(":");            int endHour = Integer.parseInt(endTimeParts[0]);            M[i][0] = charges.get(i).getPuissance();            M[i][1] = charges.get(i).getQuantity();            M[i][2] = startHour; //Long.parseLong(charges.get(i).getHeureMarche());            M[i][3] = endHour; //Long.parseLong(charges.get(i).getHeureArret());        }        long[] Pr = new long[24];        // Remplissage de Pr        for (int i = 0; i < 24; i++) {            for (int j = 0; j < M.length; j++) {                if (i >= M[j][2] && i <= (M[j][3] - 1)) {                    Pr[i] += M[j][0] * M[j][1];                }            }        }        // Affichage de Pr        for (int i = 0; i < 24; i++) {            System.out.println("Heure " + i + ": " + Pr[i]);        }        // Insérez ici le code de l'algorithme MATLAB converti en Java        return Pr;    }    @Override    public double sizingBattery(String projectId, int Nj, float D, int U) {        List<Charges> chargesByProject = findChargesByProject(projectId);        long[] energy = calculateEnergy(chargesByProject);        // Calcul de la somme des valeurs dans la liste energy        long Eb = LongStream.of(energy).sum();        System.out.println("sum: stream: " + Eb);        System.out.println("Nj: " + Nj);        System.out.println("D: " + D);        System.out.println("U: " + U);        double cb = Nj * Eb / (D * U);        System.out.println("cb: " + cb);        ResponseEntity<Project> projectOptional = findProjectById(projectId);        Project project = projectOptional.getBody();        project.setCb(cb);        projectRepository.save(project);        return cb;    }    @Override    public double sizingWt(SizingWtRequest wtRequest) throws ExecutionException, InterruptedException {        double cp = 0.59;        double rho = 1.23;        double coef = wtRequest.getCoef();        double rayon = wtRequest.getRayon();        double v;        List<Charges> chargesByProject = findChargesByProject(wtRequest.getId());        long[] energy = calculateEnergy(chargesByProject);        // Calcul de la somme des valeurs dans la liste energy        long Eb = LongStream.of(energy).sum();        //we get data from firebase to have the speed v      //  WeatherForecast data = getData(wtRequest.getId());        //J'ai WindSpeed de chaque jour : je vais prendre tous les jours du mois et puis prendre le min et puis le min de tous les mois        Double overallMinWindSpeed = null;        QuerySnapshot collection = getData();        // Itérer sur chaque document (chaque mois)        for (DocumentSnapshot document : collection.getDocuments()) {            if (document.exists()) {                List<Map<String, Object>> days = (List<Map<String, Object>>) document.get("days");                Double minWindSpeedForMonth = null;                // Itérer sur chaque jour du mois                for (Map<String, Object> day : days) {                    List<Map<String, Object>> hours = (List<Map<String, Object>>) day.get("hours");                    Double minWindSpeedForDay = null;                    // Itérer sur chaque heure du jour                    for (Map<String, Object> hour : hours) {                        Double windSpeed = (Double) hour.get("windspeed");                        if (windSpeed != null) {                            if (minWindSpeedForDay == null || windSpeed < minWindSpeedForDay) {                                minWindSpeedForDay = windSpeed;                            }                        }                    }                    // Trouver la vitesse du vent minimale du mois                    if (minWindSpeedForDay != null) {                        if (minWindSpeedForMonth == null || minWindSpeedForDay < minWindSpeedForMonth) {                            minWindSpeedForMonth = minWindSpeedForDay;                        }                    }                }                // Trouver la vitesse du vent minimale globale                if (minWindSpeedForMonth != null) {                    if (overallMinWindSpeed == null || minWindSpeedForMonth < overallMinWindSpeed) {                        overallMinWindSpeed = minWindSpeedForMonth;                    }                }                System.out.println("Mois: " + document.getId() + " --- Vitesse du vent minimale: " + minWindSpeedForMonth);            }        }        System.out.println("Vitesse du vent minimale globale: " + overallMinWindSpeed);            /*for (DocumentSnapshot document : querySnapshot.getDocuments()) {                if (document.exists()) {                    String month = document.getId();                    Long queryCost = document.getLong("queryCost");                    queryCosts.add("Month: " + month + ", QueryCost: " + queryCost);                    System.out.println("Month: "+month+ "--- QueryCost:"+queryCost);                }            }*/        //we will have minSpeed is the minimum value of wind speed for all the 40 values        v = overallMinWindSpeed;//on associe min speed a la vitesse        System.out.println("l'energie totale: " + Eb);        if (wtRequest.getPrecup()==0){            double Precup = Eb / (coef);            wtRequest.setPrecup(Precup);        }        System.out.println("coef: " + coef);        System.out.println("RAYON: " + rayon);        System.out.println("P recup: " + wtRequest.getPrecup());        double Rt = Math.sqrt(2 * wtRequest.getPrecup() / (cp * rho * Math.PI * Math.pow(v, 3)));        System.out.println("Rt: " + Rt);        double Ne = Math.ceil(Rt / rayon);        System.out.println("Ne: " + Ne);        return Ne;    }    @Override    public double[] sizingPv(SizingPvRequest sizingPvRequest) throws ExecutionException, InterruptedException {        double[][] Pr = {                {0.55, 0.6, 0.65, 0.7},                {0.6, 0.65, 0.7, 0.75}        };        //we get Eb        List<Charges> chargesByProject = findChargesByProject(sizingPvRequest.getId());        long[] energy = calculateEnergy(chargesByProject);        // Calcul de la somme des valeurs dans la liste energy        if(sizingPvRequest.getEb()==0){            long Eb = LongStream.of(energy).sum();            sizingPvRequest.setEb(Eb);        }        System.out.println("Eb de request : "+sizingPvRequest.getEb());        //we get data to calculate Ei     //   WeatherForecast data = getData(sizingPvRequest.getId());     //   WeatherForecast data = (WeatherForecast) getData();        //double Ei = 5.6;        // je veux recuperer l'irradiation minimale        Double overallMinSolarRadiation = null;        QuerySnapshot collection = getData();        // Itérer sur chaque document (chaque mois)        for (DocumentSnapshot document : collection.getDocuments()) {            if (document.exists()) {                List<Map<String, Object>> days = (List<Map<String, Object>>) document.get("days");                Double minSolarRadiationForMonth = null;                // Itérer sur chaque jour du mois                for (Map<String, Object> day : days) {                    List<Map<String, Object>> hours = (List<Map<String, Object>>) day.get("hours");                    Double minSolarRadiationForDay = null;                    // Itérer sur chaque heure du jour                    for (Map<String, Object> hour : hours) {                        Double solarradiation = (Double) hour.get("solarradiation");                        if (solarradiation != null && solarradiation != 0) {                            if (minSolarRadiationForDay == null || solarradiation < minSolarRadiationForDay) {                                minSolarRadiationForDay = solarradiation;                            }                        }                    }                    // Trouver la vitesse du vent minimale du mois                    if (minSolarRadiationForDay != null) {                        if (minSolarRadiationForMonth == null || minSolarRadiationForDay < minSolarRadiationForMonth) {                            minSolarRadiationForMonth = minSolarRadiationForDay;                        }                    }                }                // Trouver la vitesse du vent minimale globale                if (minSolarRadiationForMonth != null) {                    if (overallMinSolarRadiation == null || minSolarRadiationForMonth < overallMinSolarRadiation) {                        overallMinSolarRadiation = minSolarRadiationForMonth;                    }                }                System.out.println("Mois: " + document.getId() + " --- radiation solaire minimale: " + minSolarRadiationForMonth);            }        }        System.out.println("-mppt:" + sizingPvRequest.getMppt() + "-vm:" + sizingPvRequest.getVm());        System.out.println("-Pr data-" + Pr[sizingPvRequest.getMppt()][sizingPvRequest.getVm()]);        //we calculate Pct        double Pct = (sizingPvRequest.getEb() * 1000) / (overallMinSolarRadiation * Pr[sizingPvRequest.getMppt()][sizingPvRequest.getVm()]);        //le nbre totale des panneaux        double Npv = Pct / sizingPvRequest.getPu();        double r = Math.sqrt(Npv);        //on prend juste la partie entière majoré        double Nss = Math.ceil(r);//Nss est la partie entière juste supérieur a r        double Np = Math.ceil(Npv / Nss);        // Création et initialisation du tableau avec Np, Nss, et Npv        System.out.println("Pct: "+Pct+" , Pu: "+sizingPvRequest.getPu()+", Npv: "+Npv+" , r: "+r+" ,Nss: "+Nss+", Np: "+Np);        double[] result = new double[3];        result[0] = Np;        result[1] = Nss;        result[2] = Npv;        return result;    }    @Override    public void deleteChargeById(String id) {        chargeRepository.deleteById(id);    }   //celle ci va etre supprimé par ce que le service va etre fait dans feign qui va envoyer la requete vers l'autre micro service    @Override    public void uploadData(double longitude, double latitude, String projectId) {        //we call the micro service spring batch        //on a pas envoyer la requete d'une maniere programmatique ms declarative        batchServiceRest.uploadData(latitude,longitude,projectId);        System.out.println("Requête envoyée avec succès au microservice Spring Batch.");        /*        // URL du point de terminaison du microservice Spring Batch        String url = "http://localhost:8082/batch?lat=" + latitude + "&lon=" + longitude + "&id=" + projectId;        // Envoie de la requête au microservice Spring Batch        ResponseEntity<Void> response = new RestTemplate().postForEntity(url, null, Void.class);        // Vérification de la réponse        if (response.getStatusCode().is2xxSuccessful()) {            System.out.println("Requête envoyée avec succès au microservice Spring Batch.");        } else {            System.err.println("Erreur lors de l'envoi de la requête au microservice Spring Batch.");        }*/    }    @Override    public QuerySnapshot getData() throws ExecutionException, InterruptedException {        //je veux itérer sur tous les doncuments et afficher une propererietes.        Firestore db = FirestoreClient.getFirestore();        QuerySnapshot querySnapshot = null;        try {            CollectionReference weatherCollection = db.collection("weather");            ApiFuture<QuerySnapshot> future = weatherCollection.get();            querySnapshot = future.get();        } catch (InterruptedException | ExecutionException e) {            e.printStackTrace();        }        return querySnapshot;        //Recuperer les données a partir de firebase       /* DocumentReference docRef = db.collection("weather").document(documentId);// asynchronously retrieve the document        ApiFuture<DocumentSnapshot> future = docRef.get();// block on response        DocumentSnapshot document = future.get();        WeatherForecast weatherForecast = null;        if (document.exists()) {            // convert document to POJO            weatherForecast = document.toObject(WeatherForecast.class);            System.out.println(weatherForecast);        } else {            System.out.println("No such document!");        }        return weatherForecast;*/    }@Override    public double[][] algo3(ManagementRequest managementRequest) throws ExecutionException, InterruptedException {        try {            double Ndc = 0.95;            double Nred = 0.95;            double Nc = 0.85;            double Nd = 0.85;            double Ng = 0.9;            double rho = 1.23;            double Cp = 0.59;            eng = MatlabEngine.startMatlab();           // int daysInYear = 365;           // int daysInYear = 1;            List<Charges> chargesByProject = findChargesByProject(managementRequest.getId());            long[] energy = calculateEnergy(chargesByProject);//pour une jounée            // Maintenant, energyForYear contient la consommation d'énergie pour une année complète            double c = managementRequest.getC();            double u = managementRequest.getU();            float d = managementRequest.getD();            int nj = managementRequest.getNj();            double r = managementRequest.getRayon();            double nss = managementRequest.getNss();            double np = managementRequest.getNp();            //les conditions météorologiqe            //we get data        /*WeatherForecast data = getData(managementRequest.getId());        List<Double> T = new ArrayList<>();        for (int i = 0; i < data.getList().size(); i++) {            T.add(data.getList().get(i).getMain().getTemp());        }        List<Double> Wind = new ArrayList<>();        for (int i = 0; i < data.getList().size(); i++) {            Wind.add(data.getList().get(i).getWind().getSpeed());        }        //il me faut encore des irradiations        List<Double> G = new ArrayList<>();*/            // Nombre total d'heures dans une année          //  int totalHours = 365 * 24;            int totalHours = 1 * 24;            List<Double> windspeedList = new ArrayList<>();// Liste pour stocker la vitesse du vent            List<Double> tempList = new ArrayList<>();// Liste pour stocker les températures            List<Double> solarradiationList = new ArrayList<>();// Liste pour stocker les irradiations            //Remplissage des liste d'apres la bdd firestore :            QuerySnapshot collection = getData();            // Itérer sur chaque document (chaque mois)            for (DocumentSnapshot document : collection.getDocuments()) {                if (document.exists()) {                    List<Map<String, Object>> days = (List<Map<String, Object>>) document.get("days");                    // Itérer sur chaque jour du mois                    for (Map<String, Object> day : days) {                        List<Map<String, Object>> hours = (List<Map<String, Object>>) day.get("hours");                        // Itérer sur chaque heure du jour                        for (Map<String, Object> hour : hours) {                            Double windSpeed = (Double) hour.get("windspeed");                            Double temp = (Double) hour.get("temp");                            Double solarradiation = (Double) hour.get("solarradiation");                            // Ajouter les valeurs aux listes respectives, en utilisant 0 si elles sont nulles                            windspeedList.add(windSpeed != null ? windSpeed : 0);                            tempList.add(temp != null ? temp : 0);                            solarradiationList.add(solarradiation != null ? solarradiation : 0);                        }                    }                }            }            // Afficher les tailles des listes pour vérifier            System.out.println("Total windspeed values: " + windspeedList.size());            System.out.println("Total temp values: " + tempList.size());            System.out.println("Total solarradiation values: " + solarradiationList.size());            // Vérification du remplissage des listes (facultatif)            System.out.println("Températures : " + tempList);            System.out.println("Vitesse du vent : " + windspeedList);            System.out.println("Irradiations : " + solarradiationList);            // Initialiser un tableau pour stocker la consommation d'énergie sur une année            long[] energyForYear = new long[windspeedList.size()];            // Répéter la liste de consommation d'énergie pour chaque jour de l'année            for (int i = 0; i < ((windspeedList.size())/24); i++) {                // Copier chaque élément de la consommation d'énergie journalière dans le tableau de l'année                System.arraycopy(energy, 0, energyForYear, i * 24, 24);            }            int size = windspeedList.size();            //initialisation des parametres de stockage            double[] SOC = new double[size+1];            double[] Pbatt = new double[size];//je sais pas c quoi son utilité            double[] dd = new double[size];            double[][] P = new double[size][6]; // ici ou on stocke le resultat de l'algorithme            // 6 cad de 0 a 5            // État de charge maximal à ne pas dépasser par la batterie            SOC[0] = 100;            double SOCmax = 100; // État de charge maximal            double SOCmin = 100 - d; // État de charge minimal            // La puissance de la batterie maximale            double[] Ebatt = new double[size+1];            Ebatt[0] = c * u; // Capacité multipliée par la tension choisie par l’utilisateur            double Ebattmax = c * u;            double Ebattmin = c * u * (100 - d);            double EbattC = c * u / (nj * 24); // Pour ne pas dépasser le courant de charge nominal            //initialisation de Pmpp , Pwind et Ebattup            double[] Pmpp = new double[size];            double[] Pwind = new double[size];            double[] Ebattup = new double[size];            // Boucle principale            for (int i = 0; i < size; i++) {//size c'est 24 hours                System.out.println("debut de for: i="+ i);                // La collecte de données                double[] P0 = new double[]{0, 0, 0, 0, 0}; // Initialisation de vecteur de puissance                Pmpp[i] = mppt(solarradiationList.get(i), tempList.get(i), nss, np) * Ndc;                System.out.println("pmpp[i]: " + Pmpp[i]); // la question qui se pose c que pq Pmpp est infinity                Pwind[i] = 0.5 * rho * Math.PI * Math.pow(r, 2) * Cp * Math.pow(windspeedList.get(i), 3) * Ndc * Nred;                System.out.println("pwind[i]: " + Pwind[i]);                Ebattup[i] = (Ebatt[i] - Ebattmin) / 72; // La quantité d'énergie réservée journalièrement                double[] Aeq = new double[]{};                double[] beq = new double[]{};                double[][] A = new double[][]{                        {1.0, 0.0, 0.0, 1.0, 0.0},                        {0.0, 1.0, 0.0, 0.0, 1.0}                };// Coefficients pour les contraintes linéaires                double[] b = new double[]{Pmpp[i], Pwind[i]};                double[] lb = new double[]{0, 0, 0, 0, 0};                double[] ubb = new double[]{Pmpp[i], Pwind[i], Ebattup[i], Pmpp[i], Pwind[i]};                //double[] ubb = new double[]{1, 1, 1, 1, 1};                // Conditions pour les contraintes d'inégalités                if (Pmpp[i] + Pwind[i] >= energyForYear[i]) {                    if (SOC[i] < SOCmax) {                        dd[i] = -1;                    }else {                        dd[i] = 0;                    }                }//je dois al                if (Pmpp[i] + Pwind[i] <= energyForYear[i]) {                    if (SOC[i] > SOCmin) {                        dd[i] = 1;                    } else if (SOC[i] == SOCmin) {                        dd[i] = 0;                    }                }                //lb est tjr 0 , on détérmine ub                if (dd[i] == -1) {                    ubb = new double[]{Pmpp[i], Pwind[i], EbattC, Pmpp[i], Pwind[i]};                } else if (dd[i] == 0) {                    ubb = new double[]{Pmpp[i], Pwind[i], 0, Pmpp[i], Pwind[i]};                } else if (dd[i] == 1) {                    ubb = new double[]{Pmpp[i], Pwind[i], Ebattup[i], Pmpp[i], Pwind[i]};                }                //on appelle la fonction d'optimisation de matlab :                // Définir la fonction objective comme une chaîne MATLAB                String objectiveFunction = "objective";                String nlcon = "nlcon";                //on a 2 arguments d(i) et Pload(i)                double arg1 = dd[i]; // Exemple d'argument supplémentaire: ca c'est e                double arg2 = energyForYear[i];                //String options = "optimoptions(@fmincon,'Algorithm','sqp')"; // Example options string                //double[] p =  {1.0, -1.0, -6.0};                eng.putVariable("e", arg1);                eng.putVariable("d", arg2);                Object fmincon = eng.feval("fmincon", objectiveFunction, P0, A, b, Aeq, beq, lb, ubb, nlcon);                // Afficher le résultat                System.out.println("Solution optimale : " + fmincon.toString());                // Convertir l'objet Object en tableau de doubles                double[] result = (double[]) fmincon;                System.out.println("result: " + result);                //P[i]=result; //P contient 6 elements et result va contenir la meme chose que P0 donc 5 elements                int v = 0;                //On remplie P :                for (double value : result) {//result contient 5 elements                    P[i][v] = result[v];                    v++;                }                // Afficher le résultat                System.out.print("Solution optimale pour i: ");                for (double value : result) {                    System.out.print(value + " ");                }                System.out.println(); // Ajouter un saut de ligne à la fin                // Fermer le moteur MATLAB                if (dd[i] == -1) {                    // Appeler la fonction StateOfCharge pour mettre à jour SOC et Ebatt                    double[] doubles = stateOfCharge(SOC[i], P[i][2], Ebatt[i], c, u);                    SOC[i + 1] = doubles[0];                    Ebatt[i + 1] = doubles[1];                } else {                    double[] doubles = stateOfCharge(SOC[i], -dd[i] * P[i][2], Ebatt[i], c, u);                    SOC[i + 1] = doubles[0];                    Ebatt[i + 1] = doubles[1];                }                System.out.println("avant catch !");//             [P(:,i),feval(i)]= fmincon(fun,P0,A,b,Aeq,beq,lb,ub,nonlcon);                // Appeler fmincon/* c ce que m'a donné chat gpt pour recuperer le resultat            // Récupérer le résultat comme un tableau d'objets            Object[] resultArray = (Object[]) fminconResult;            // Récupérer la solution optimale            double[] optimalSolution = (double[]) resultArray[0];            // Stocker la solution optimale dans P[i]            P[i] = optimalSolution;            // Récupérer la valeur de la fonction objectif            double objectiveValue = (double) resultArray[1];            System.out.println("Valeur de la fonction objectif : " + objectiveValue);*/                System.out.println("fin de for 1: ");            }//fin de for            eng.close();            System.out.println("fin de for 2: ");        // Multiplication de P(3,:) par d        for (int j = 0; j < size; j++) {            P[j][2] *= dd[j];        }        // Boucle pour calculer P(6,:)        for (int i = 0; i < size; i++) {            if (dd[i] != -1) {                //on ajoute a P une colonne on avait : 5 colonnes on ajoute la sixième colonne                //que signifie : P[i][5]                P[i][5] = -P[i][0] - P[i][1] - P[i][2] + energyForYear[i];            } else {                P[i][5] = 0;            }        }  System.out.println("avant catch2 !");            return P;        }catch (Exception e) {            log.error("Erreur lors de l'appel MATLAB : ", e);            throw new IllegalStateException("Erreur dans l'appel MATLAB", e);        }    } //fin de l'algo 3    @Override    public double algo2(AlgoTwoRequest algoTwoRequest) throws ExecutionException, InterruptedException {        //dans cette methode on fait appel au methodes de algo2, algo3, algo4. On peut l'appler Sizing        double biggest=0;        double ne_retenu=0;        double[] n_variables_retenu;        //ces deux variables vont prendre la configuration finale        //on appelle les methodes de algo2 de chaque systeme        double cb = sizingBattery(algoTwoRequest.getId(), algoTwoRequest.getNj(), algoTwoRequest.getD(), algoTwoRequest.getU());        SizingWtRequest sizingWtRequest=new SizingWtRequest(algoTwoRequest.getId(),algoTwoRequest.getRayon(),algoTwoRequest.getCoef(),0);//au debut on donne a precup 0        double ne = sizingWt(sizingWtRequest);        SizingPvRequest sizingPvRequest=new SizingPvRequest(algoTwoRequest.getId(),algoTwoRequest.getMppt(),algoTwoRequest.getVm(),algoTwoRequest.getPu(),0);        double[] n_variables = sizingPv(sizingPvRequest);//on peut meme recuprer npp et nss        //on appelle l'algo 3 qui est management on lui donne les données de request algo2, les resultat de algo2 npp nss        ManagementRequest managementRequest=new ManagementRequest(algoTwoRequest.getId(),algoTwoRequest.getNj(),algoTwoRequest.getD(),algoTwoRequest.getU(),algoTwoRequest.getRayon(),cb,n_variables[1],n_variables[0]);        double[][] p = algo3(managementRequest);        double [][] config_p=p;        System.out.println("fin de l'appel de algo 3 et début de clustering : ");        //l'algo 3 , on recupere P on lui donne au clustering algorithm        Map<Centroid, List<Record> > clustering = clustering(p);        System.out.println("retour de clustering: "+clustering);        //on va repeter l'algo 2 et 3 pour les centroids        //on commence a implementer algo4        //on prend chaque centroid : on a 3        //le premier centroid :        int j=0;        Map<String, Double> resultsMap = new HashMap<>();//ici on va stocker chaque centroid, et un tableau qui contient sum et p de centroid        Centroid centroid1=new Centroid(resultsMap);        for (Map.Entry<Centroid, List<Record>> entry : clustering.entrySet()) {            j++;            System.out.println("dans la boucle de centroid clustering:"+j);            //le premier centroid :            Centroid centroid = entry.getKey();            System.out.println("key : "+j+"-"+centroid);            List<Record> records = entry.getValue();            // Faites quelque chose avec centroid et records            //on lance le deuxieme algo pour ce centre , et on doit donner a Precup Pwt, et a Eb Ppv.            //pour l'eolien            sizingWtRequest.setPrecup(centroid.getCoordinates().get("Pwt"));//il faut savoir liste ou tableaux            System.out.println("les coordonnes de centoid: "+centroid.getCoordinates()); //il me faut les coordonnées            ne=sizingWt(sizingWtRequest);            //pour PV            sizingPvRequest.setEb(centroid.getCoordinates().get("Ppv"));            n_variables = sizingPv(sizingPvRequest);//on peut meme recuprer npp et nss            //pour lancer l'algo 3 on aura besoin de np et nss            managementRequest.setNss(n_variables[1]);            managementRequest.setNp(n_variables[0]);            p = algo3(managementRequest);            System.out.println("length de p de centroid: "+p.length);            //j'affiche le contenu de centroid!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!            //pour ce centroid on doit faire un calcul et on fait la somme pour toute l'année            double sum=0;            for (int i = 0; i < p.length; i++) {                sum+=p[i][0]+p[i][1]+p[i][2]-p[i][5];            }            if(sum>biggest){                biggest=sum;                config_p=p;                centroid1 = entry.getKey();//on recupere le centroid associé a cette grande valeur                //on stocke meme les valeurs de dimensionnement(cad algo2) associé a ce centroid                ne_retenu=ne;                n_variables_retenu=n_variables;            }            System.out.println("biggest: "+biggest);            //je dois stocker cette valeur qui correspond a chaque cluster et enfin retenir P du cluster qui a la plus grande valeur de sum.        }//fin de for        System.out.println("la somme la plus grande : "+biggest);        System.out.println("le centroid associé : "+centroid1);        System.out.println("p associé : ");        //on affiche chaque element de p        for (int i = 0; i < config_p.length; i++) {            System.out.println("p for : "+i+", {Ppv="+config_p[i][0]+", Pwt="+config_p[i][1]+", Pbatt= "+config_p[i][2]+", PpvG="+config_p[i][3]+" PwtG="+config_p[i][4]+", Pload="+config_p[i][5]+"}");        }        return biggest;    }    @Override    public Map<Centroid, List<Record>> clustering(double[][] P) {        System.out.println("debut de la methode clustering: ");        //je recois le tableau P contient tous les colonnes je le convertit en liste de 2 colonnes        List<Record> records = new ArrayList<>();        System.out.print("length of P : "+P.length);        for (int i = 0; i < P.length; i++) {            double[] row = P[i];            double Ppv = row[0];            double Pwt = row[1];            // Créer un map de features avec le nom de colonne et sa valeur            Map<String, Double> features = new HashMap<>();            features.put("Ppv", Ppv);            features.put("Pwt", Pwt);            // Créer un nouvel objet Record avec le numéro de ligne comme description et les features            Record record = new Record("Ligne " + (i + 1), features);            records.add(record);        }        // Afficher les enregistrements        for (Record record : records) {            System.out.println(record);        }        Kmeans KMeans=new Kmeans();        //ici on run Kmeans function:     /*   Distance distance = new EuclideanDistance();        List<Double> sumOfSquaredErrors = new ArrayList<>();        for (int k = 2; k <= 16; k++) {            Map<Centroid, List<Record>> clusters = KMeans.fit(records, k, distance, 1000);            double sse = sse(clusters, distance);            sumOfSquaredErrors.add(sse);        }        System.out.println(sumOfSquaredErrors);*/        Map<Centroid, List<Record>> clusters = KMeans.fit(records, 3, new EuclideanDistance(), 1000);// Printing the cluster configuration        clusters.forEach((key, value) -> {            System.out.println("-------------------------- CLUSTER ----------------------------"+ key);            // Sorting the coordinates to see the most significant tags first.            //   System.out.println(sortedCentroid(key));            String members = String.join(", ", value.stream().map(Record::getDescription).collect(toSet()));            System.out.print(members);            System.out.println();            System.out.println();        });        //maintenant on a les clusters .        return clusters;    }    public static double sse(Map<Centroid, List<Record>> clustered, Distance distance) {        double sum = 0;        for (Map.Entry<Centroid, List<Record>> entry : clustered.entrySet()) {            Centroid centroid = entry.getKey();            for (Record record : entry.getValue()) {                double d = distance.calculate(centroid.getCoordinates(), record.getFeatures());                sum += Math.pow(d, 2);            }        }        return sum;    }    double mppt(double g , double t, double nss, double np){        t += 273.15;        double Gn = 1000;        double Iscn = 9.43;        double Ki = 0.004745;        double Tn = 25 + 273.15;        double Vcon = 39;        double Kv = -0.1131;        double n = 1.3;        double kB = 1.3806503e-23;        double q = 1.6021764e-19;        double Ns = 60;        //c quoi ce v :        double[] V = new double[501]; // 0 à 50 volts par incrément de 0.1        for (int i = 0; i < 501; i++) {            V[i] = i * nss;        }        double A = (g / Gn) * (Iscn + Ki * (t - Tn))*np; // Calcul de la constante A        System.out.println("g: "+g+", np: "+np);        System.out.println("(g / Gn): "+(g / Gn)+", (Iscn + Ki * (t - Tn))*np: "+(Iscn + Ki * (t - Tn))*np);        double Vt = (n * Ns * kB * t * nss) / q; // Calcul de la constante Vt        double B = (Iscn + Ki * (t - Tn)) * np/(exp((Vcon + Kv * (t - Tn)) * nss / Vt) - 1);        double[] I = new double[501];        double[] P = new double[501];        for (int i = 0; i < V.length; i++) {            I[i]=(A-B*exp(V[i]/Vt));//calcul du courant de sortie            P[i]= I[i]*V[i];// Calcul de la puissance        }        System.out.println("A: "+A);        System.out.println("B: "+B);        System.out.println("Vt: "+Vt);        System.out.println("lambert: "+lambertw(0, (A * exp(1)) / B));        System.out.println("inside exp: "+ (Vt*(lambertw(0,(A*exp(1))/B)- 1))/Vt);        System.out.println("exp value :"+Math.exp((Vt*(lambertw(0,(A*exp(1))/B)- 1))/Vt) );        System.out.println("first value :"+(A-B*exp((Vt*(lambertw(0,(A*exp(1))/B)-                1))/Vt)));        System.out.println("second value: "+(Vt*(lambertw(0,(A*exp(1))/B)-1)));        //double lambertValue = 0;        try {            MatlabEngine eng = MatlabEngine.startMatlab();            double lambertValue = eng.feval("lambertw", 0, (A * Math.exp(1)) / B);            eng.close();            System.out.println("lambert de matlab: "+lambertValue);            //  double Vmpp = (Vt * (lambertw(0, (A * exp(1)) / B) - 1)); // Calcul de la tension correspondant à Pmax            double Vmpp = (Vt * (lambertValue - 1)); // Calcul de la tension correspondant à Pmax            //double Pmpp= (A - B * exp(( Vt * (lambertw(0, (A * exp(1)) / B) - 1)) / Vt)) * (Vt * (lambertw(0, (A * exp(1)) / B) - 1));            double Pmpp=(A-B*exp((Vt*(lambertValue-                    1))/Vt))*(Vt*(lambertValue-1));            double Impp=(A-B*exp(Vmpp/Vt));//le courant qui correspond a Pmpp            System.out.println("pmpp dans la methode: "+ Pmpp);            return Pmpp;        } catch (Exception e) {            e.printStackTrace();        }        // return Pmpp;//le probleme cq ue les valeurs de inside expo sont tres grande ce qui donne infinity car exp d'une l'infinie donne infinie donc je dois appler lambertw de matlab car c lui qui donne une grande valeur        return 0;    }//finish of mppt    public static double lambertw(double k, double z) {        double epsilon = 1e-10; // Précision        double w = z;        double wPrev = w + 2 * epsilon;        while (Math.abs(w - wPrev) > epsilon) {            wPrev = w;            double ew = Math.exp(w);            double ewMinusOne = Math.exp(w - 1);            w = w - (w * ew - z) / (w * ew - w + 1);        }        return w+k;    }    // Fonction de décharge et charge de la batterie    public static double[] stateOfCharge(double SOC, double Pbus, double Ebatt, double c, double u) {        double NDC = 0.95;        double Nc = 0.85;        double Nd = 0.85;        double SOCmax = 100;        double Ebattmax = c * u; // Pendant un time slot de 1h        double dEbatt;        if (Pbus > 0) {            dEbatt = Pbus * Nc * NDC;        } else {            dEbatt = Pbus / (Nd * NDC);        }        Ebatt += dEbatt;        SOC = (Ebatt / Ebattmax) * 100;        if (SOC >= 100) {            SOC = SOCmax;        }        if (Ebatt >= Ebattmax) {            Ebatt = Ebattmax;        }        return new double[]{SOC, Ebatt};    }    //le clustering}